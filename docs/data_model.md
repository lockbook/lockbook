# Data Model and Procedures

Thinking and reasoning about things related to lockbook require you to understand the following 2 structs, and the associated operations we do on them. 

## [Accounts](https://github.com/lockbook/lockbook/blob/master/core/src/model/account.rs)

+ `username` - unique identifier for a user, `[a-z][0-9]`
+ `keypair` - RSA Keypair, generated by clients, the public component is uploaded to the server.

## [File](https://github.com/lockbook/lockbook/blob/master/core/src/model/file_metadata.rs)

+ `id` - [Uuid](https://en.wikipedia.org/wiki/Universally_unique_identifier)
+ `file_type` - A `File` could represent a `Folder` (which contains more files) or a `Document`
+ `parent` - The `id` of the parent folder which this files resides inside.
+ `name`
+ `owner`
+ `signature` - Proof that the `owner` created this file.
+ `metadata_version` - A `u64` that represents this struct's version.
+ `content_version` - If the `File` is a `Document` this corresponds to that content's `version`. `id` also represents the Document's `id` if this is a `Document`. 
+ `user_access_keys` - The decryption key for this `File` encrypted by the `public_key` of a particular user.
+ `folder_access_keys` - The decryption key for this `File` encrypted by the encryption key of the `parent` of this folder.

### Versions

Every change to a `File` increments it's `metadata_version`. This ensures that if you `delete` a file you have the most recent version of the file. The primary motivation is to prevent race conditions. The server is responsible for doing checks and incrementing versions.

Similarly, every change to a `Document`s content increments it's `content` version. The reason this is it's own field is to only download a file out of S3 (expensive) if we need to.

### Access Keys

When a client authors a file they generate a 256 bit `AES` key. Content is encrypted with this key. Each `File` gets it's own key. These keys are encrypted either with the `AES` key of a `Folder` or the `public_key` of a user.

Every user is given a `root` folder during account creation. And every file they create exists somewhere inside this root folder. The `root` folder is the folder that has their `username` mapped to `AES key for the root folder` encrypted with their `public_key` (only they can access their root folder's "Access Key").

The procedure for decrypting a given file is:
```
1. Is there an entry with my username in the user_access_keys for this file? If so decrypt the key, use that key to decrypt the file. <Done>
2. Grab the decryption key for this file's parent. Decrypt the key with the parent's key, use that key to decrypt this file. <Done>
```

In this procedure 2 is a recursive action. Decrypting a file often means walking through your folder structure to your root folder where you'll find the 1 key you can decrypt with your `public_key`. 

The motivation for this design is the flexibility it gives us around sharing. You can share a file directly with someone. The procedure for that looks something like this:

```
1. Decrypt the key for this file, let's refer to this as *secret*. (See above)
2. Lookup their public key. Encrypt *secret* with their public_key.
3. Add an entry to user_access_keys with their username -> encrypted *secret*
```

Parallel to their root folder, in a `shared_with_me/` folder this `File` will show up.

This works for `Document`s as well as `Folder`s. Consider the procedure for decrypting a given file that is shared with you and is a folder with hundreds of documents.

The primary motivation is to be able to share both documents and folders in a way that:
1. Is trustless -- Lockbook server will never handle these secrets, all secrets stay in an encrypted form.
2. Is effecient -- Share a folder with hundreds of documents sub-folders, etc without having to perform more than 1 cryptographic operation.
3. Is flexible -- Given an organizational structure with multiple people having different levels of access. This allows you to share the root folder with administrators, the engineering folder with engineers and the hr folder with your people team.

There is an implicit `name`->`public_key` resolution attack vector here -- lockbook servers could lie about what a `username`'s `public_key` is. The only solution to this problem is out of band (ideally in person) verification of `public_key`s. Our process will likely look something [like Signal's](https://support.signal.org/hc/en-us/articles/360007060632-What-is-a-safety-number-and-why-do-I-see-that-it-changed-) except the `username -> public_key` relationship is immutable within lockbook.

### Sync

When a client goes to sync for the first time (let's pretend their account has several files), they will `/get-updates` with an input value of `0`. This signifies they want to receive the record of everything that has happened. They'll receive a `Vec<FileMetadata>` objects and will retrieve the corresponding files out of `S3`.

As someone continues using both devices, online and offline, the sync process becomes a bit more complex.

Clients keep track of what has changed locally. These changes look something like:
+ `Rename(old, new)`
+ `Edit(old_checksum, new_checksum)`
+ Etc

When they call `get-updates` they pass the largest `metadata_version` they have. Any files they don't know about (are new) are resolved trivially, any local changes are pushed up. For files that have changed remotely, and have changed locally, an attempt to merge the changes is made. If you moved a file remotely and renamed it locally there is no conflict. If you have local edits and remote edits, they are merged `git` style. In cases where there's a truly unresolvable conflict (remote and local both rename a file), the server wins.

All edits are cryptographically signed, and clients verify that they are genuine before altering their local state. [No one should ever be able to impersonate a user of Lockbook.](https://en.wikipedia.org/wiki/2020_Twitter_bitcoin_scam)

The specifics of how `sync` happens can be found in [`sync_service.rs`](https://github.com/lockbook/lockbook/blob/master/core/src/service/sync_service.rs).